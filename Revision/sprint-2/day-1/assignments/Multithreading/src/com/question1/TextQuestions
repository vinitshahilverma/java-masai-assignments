1. WHAT IS THE NEED FOR THREADS IN JAVA?

Answer:- 1.A thread is part of sub-process of an application.

         2.A thread is a lightweight sub-process, the smallest unit of processing. It is a separate 
          path of execution.
          
         3.A thread is a separate flow of execution some functionality of a program with the other 
           part of the program simultaneously.
         
2. HOW DO YOU CREATE A THREAD?

Answer:- Creating a Thread is a two step process:-
         
         1. We have to define a functionality that can be executed as a thread along with the 
            main thread.
            
         2. Start that functionality as a thread.
                     
3. HOW DO YOU CREATE A THREAD BY EXTENDING THREAD CLASS?

Answer:- public class ThreadImpl1 extends Thread{

	
	@Override
	public void run() {
		
		synchronized (this) {
			int sum =0;
			for(int i=1; i<=10000; i++) {
				sum = sum + i;
			}
			System.out.println(sum+" from ThreadImpl1");
			this.notify();
		}
	}

}

4. HOW DO YOU CREATE A THREAD BY IMPLEMENTING RUNNABLE INTERFACE?

Answer:- public class ThreadImpl2 implements Runnable{

	@Override
	public void run() {
		
		synchronized (this) {
			int sum = 0;
			for(int i=1; i<=10000; i++) {
				sum = sum + i;
			}
			System.out.println(sum+ " From ThreadImpl2");
             this.notify();
		}  
		
	}

}

5. HOW DO YOU RUN A THREAD IN JAVA?

Answer:- public class Test {
	
	public static void main(String[] args) {
		
		 ThreadImpl1 t1 = new ThreadImpl1();
		 ThreadImpl2 t2 = new ThreadImpl2();
		 
		 Thread t3 = new Thread(t2);
		 
		 t3.start();
	
	     t1.start();

	}

}

6. WHAT ARE THE DIFFERENT STATES OF A THREAD?

Answer:- There are five states of a Thread:-

        1.New State:- Thread t = new Thread();
                       when a new thread born.
                       
        2.Runnable state:- t.start();
                            when a thread starts in main method.
                            
                            
        3.Running state:- Selected by thread scheduler to run.
        
        4.Block state:- When wait(), sleep(), join() methods call on the thread than this
                         state is called Block state.
                         
        5.Dead state :- After completion of run() method.
        
7. WHAT IS PRIORITY OF A THREAD? HOW DO YOU CHANGE THE PRIORITY OF A THREAD?

Answer:- Every Thread has a priority. It may be default priority generated by the JVM or 
         explicitly provided by the programmer.
         
         The valid range of the thread priority is 1 to 10 not 0 to 0.
         10 is the highest and 1 is the lowest.
         
         Thread provides following setter and getter methods to set the priority and get the 
         priority.
         
         1. public final void setPriority(int priority);
         2. public final int getPriority();
         
         
         t.setPriority to set the priority.
         t.getPriority to get the priority.
         

 8. WHAT IS EXECUTORSERVICE?
 
 Answer:- ExecutorService helps is maintaining the thread poll and providing them tasks.
          It also provides the facility to queue up the the task until a free Thread is available
          if the number of task is more than the thread available.
          
          Basically it is use to execute the Thread poll.
          
          It belongs to java.util.concurrent package.
          
 9. CAN YOU GIVE AN EXAMPLE FOR EXECUTORSERVICE?
 
 Answer:-  public class PrintName implements Runnable{
	
	String name;
	
	public PrintName(String name) {
		this.name = name;
	}

	@Override
	public void run() {
		
		System.out.println( name + "job started by thread: "+ Thread.currentThread().getName());
		
		try {
			Thread.sleep(2000);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		System.out.println( name + "job completed by thread: "+ Thread.currentThread().getName());
	}

}


public class Main {

	public static void main(String[] args) {
		
		PrintName[] name = {
				
			   new PrintName("Ram"),
			   new PrintName("Ravi"),
			   new PrintName("Shayam"),
			   new PrintName("Sunil"),
			   new PrintName("Suresh"),
			   new PrintName("Pavan"),
			   
		};
		
		ExecutorService service = Executors.newFixedThreadPool(3);
		
		for(PrintName n:name) {
			service.submit(n);
		}
		
		service.shutdown();//to shutdown the excecutorService.
		
	}

}

10. EXPLAIN DIFFERENT WAYS OF CREATING EXECUTORSERVICES?

Answer:- Different ways creating ExecutorServices.
       
       1.ExecutorService executorService1 = Executors.newSingleThreadExecutor(); 
       //Creates //a ExecutorService object having a single thread.  
  
       2.ExecutorService executorService2 = Executors.newFixedThreadPool(10);  
       // Creates a //ExecutorService object having a pool of 10 threads.  
  
       3.ExecutorService executorService3 = Executors.newScheduledThreadPool(10); 
       //Creates a scheduled thread pool executor with 10 threads. In scheduled thread //pool, we can schedule tasks of the threads.  
          
       
11. HOW DO YOU CHECK WHETHER AN EXECUTIONSERVICE TASK EXECUTED SUCCESSFULLY?

Answer:- With the help of Future object. After submitting the task we get the future class
         object than we can check with the help of future.isDone() if it return true it means it
         is executed successfully.
         
12.WHAT IS CALLABLE? HOW DO YOU EXECUTE A CALLABLE FROM EXECUTIONSERVICE? 

Answer :- If a thread required to return return some result then we use Callable Interface instead of 
          Runnable.It belongs to java.util.concurrent package.
          This interface also contains only one method.
          
          We submit a collable object to ExecutorService object,Than after completing the task,
          thread returns an object of the Future type.
          
          The Future object can be used to retrieved the result from the Callable tasks.
          
          ExecutorService service = Executors.newFixedThreadPool(3);
          
          for(MyCallable job:jobs){
              Future f = service.submit(job);
              System.out.println(f.get());
          }
          
          }
          
  13. WHAT IS SYNCHRONIZATION OF THREADS? 
  
  Answer:- It means communication between two threads with the help of wait(),notify(),notifyAll()
           methods.
           
           Whenever we need to suspend a synchronized thread unconditionally then we use 
           wait() method.
           
           Whenever we need to resume a suspended(waiting) thread then we use notify() method.
           
           This is Threads are synchronized and communication between two threads happens.
           
 14. CAN YOU GIVE AN EXAMPLE OF A SYNCHRONIZED BLOCK?
 
 Answer:- Answer:- public class ThreadImpl2 implements Runnable{

	@Override
	public void run() {
		
		synchronized (this) {
			int sum = 0;
			for(int i=1; i<=10000; i++) {
				sum = sum + i;
			}
			System.out.println(sum+ " From ThreadImpl2");
             this.notify();
		}  
		
	}

}

15. CAN A STATIC METHOD BE SYNCHRONIZED?

Answer:- If we mark a method as Static than we get the regular output irrespective of multiple
         objects also.
         
16. WHAT IS THE USE OF JOIN METHOD IN THREADS?

Answer:- It it use to suspend a thread conditionally.
         If it want my thread to be execute after the completion of other thread.
         than we will use join.
         
         Thread t1 = new Thread();
         
         thread t2 = new Thread();
         
         t2.join();// on t1 class;
         
         than t1 will run after the completion of t2.
         
         
17. DESCRIBE A FEW OTHER IMPORTANT METHODS IN THREADS?

Answer:- Other methods are Sleep(),Yeild().

         Sleep(1000) :- This method will make the tread to sleep for the given time.
         Yeild:- It is method to indicate that other thread should get more preferance.
         
         
18. WHAT IS A DEADLOCK?

Answer:- DEADLOCk is condition where multiple threads are keep waiting for each other for
         infinite time.
         
19. WHAT ARE THE IMPORTANT METHODS IN JAVA FOR INTER-THREAD COMMUNICATION?

Answer:- wait(), notify(), notifyAll() are important methods for Inter-Thread Communication.

20.WHAT IS THE USE OF WAIT METHOD?

Answer:- Wait() method once call on the object first object release the object and goes into 
         waiting state.
         
21. WHAT IS THE USE OF NOTIFY METHOD?

Answer:- Once the notify() method call on the object it also release the lock but not immediately
         notify() method notify the method which is waiting for the lock to be released.
         
22. WHAT IS THE USE OF NOTIFYALL METHOD?

Answer:-   notifyAll() method notify All the methods which are waiting for the lock to be released.      
 
      
         
                               
